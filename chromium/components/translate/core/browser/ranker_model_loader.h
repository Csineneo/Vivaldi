// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_TRANSLATE_CORE_BROWSER_RANKER_MODEL_LOADER_H_
#define COMPONENTS_TRANSLATE_CORE_BROWSER_RANKER_MODEL_LOADER_H_

#include <memory>
#include <string>

#include "base/callback.h"
#include "base/memory/ref_counted.h"
#include "base/memory/weak_ptr.h"
#include "base/sequence_checker.h"

class GURL;

namespace base {
class FilePath;
class SequencedTaskRunner;
}  // namespace base

namespace chrome_intelligence {
class RankerModel;
}  // namespace chrome_intelligence

namespace translate {

// Enumeration denoting the outcome of an attempt to download the model. This
// must be kept in sync with the RankerModelStatus enum in histograms.xml
enum class RankerModelStatus {
  OK = 0,
  DOWNLOAD_THROTTLED = 1,
  DOWNLOAD_FAILED = 2,
  PARSE_FAILED = 3,
  VALIDATION_FAILED = 4,
  INCOMPATIBLE = 5,

  // Insert new values above this line.
  MAX
};

// If enabled, downloads a translate ranker model and uses it to determine
// whether the user should be given a translation prompt or not.
class RankerModelLoader {
 public:
  // Callback to validate a ranker model on behalf of the model loader client.
  // For example, the callback might validate that the model is compatible with
  // the features generated when ranking translation offerings. This callback
  // may be called on any sequence and must, therefore, be thread-safe. This
  // callback may be invoked after the RankerModelLoader has been destroyed
  // and must, therefore, only access memory that it can guarantee to be
  // valid.
  using ValidateModelCallback = base::Callback<RankerModelStatus(
      const chrome_intelligence::RankerModel& model)>;

  // Called to transfer ownership of a loaded model back to the model loader
  // client. This will be called on the sequence on which the model loader was
  // constructed.  This callback may be invoked after the RankerModelLoader has
  // been destroyed and must, therefore, only access memory that it can
  // guarantee to be valid.
  using OnModelAvailableCallback = base::Callback<void(
      std::unique_ptr<chrome_intelligence::RankerModel> model)>;

  // |validate_model_callback| may be called on any sequence; it must be thread
  // safe.
  //
  // |on_model_available_callback| will be called on the sequence on which the
  // ranker model loader is constructed.
  //
  // |model_path| denotes the file path at which the model is cached. The loader
  // will attempt to load the model from this path first, falling back to the
  // |model_url| if the model cannot be loaded or has expired. Upon downloading
  // a fresh model from |model_url| the model will be persisted to |model_path|
  // for subsequent caching.
  //
  // |model_url| denotes the URL from which the model should be loaded, if it
  // has not already been cached at |model_path|.
  //
  // |uma_prefix| will be used as a prefix for the names of all UMA metrics
  // generated by this loader.
  RankerModelLoader(const ValidateModelCallback& validate_model_callback,
                    const OnModelAvailableCallback& on_model_available_callback,
                    const base::FilePath& model_path,
                    const GURL& model_url,
                    const std::string& uma_prefix);

  ~RankerModelLoader();

  // Asynchronously initiates loading the model from the cache file path and URL
  // previously configured.
  void Start();

  // Call this method periodically to notify the model loader the ranker is
  // actively in use. The user's engagement with the feature is used as a proxy
  // for network activity. If a model download is pending, this will trigger
  // (subject to retry and frequency limits) a model download attempt.
  void NotifyOfRankerActivity();

 private:
  // The model loader backend to which the actual loading functionality is
  // delegated.
  class Backend;
  friend class Backend;

  // A enum to track the current loader state.
  enum class LoaderState { NOT_STARTED, RUNNING, FINISHED };

  // Helper method to forward OnModelAvailable callbacks while noting whether
  // or not the loader has finished its work.
  void InternalOnModelAvailable(
      const OnModelAvailableCallback& callback,
      std::unique_ptr<chrome_intelligence::RankerModel> model,
      bool finished);

  // Validates that ranker model loader tasks are all performed on the same
  // sequence.
  base::SequenceChecker sequence_checker_;

  // The task runner on which backend tasks are performed.
  const scoped_refptr<base::SequencedTaskRunner> backend_task_runner_;

  // The model loader backend to which the actual loading functionality is
  // delegated. |backend_| may outlive its RankerModelLoader. When the
  // RankerModelLoader is destroyed, ownership of |backend_| is transferred
  // to a delete task posted |backend_task_runner_|.
  std::unique_ptr<Backend> backend_;

  // The current state of the loader.
  LoaderState state_ = LoaderState::NOT_STARTED;

  base::WeakPtrFactory<RankerModelLoader> weak_ptr_factory_;

  DISALLOW_COPY_AND_ASSIGN(RankerModelLoader);
};

}  // namespace translate

#endif  // COMPONENTS_TRANSLATE_CORE_BROWSER_RANKER_MODEL_LOADER_H_
