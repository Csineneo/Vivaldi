// This file is generated

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "platform/inspector_protocol/{{class_name}}.h"

#include "platform/inspector_protocol/FrontendChannel.h"
#include "platform/inspector_protocol/Parser.h"
#include "wtf/text/CString.h"

namespace blink {
namespace protocol {

using protocol::Maybe;

class DispatcherImpl : public Dispatcher {
public:
    DispatcherImpl(FrontendChannel* frontendChannel)
        : m_frontendChannel(frontendChannel)
{% for domain in api.domains %}
        , m_{{domain.domain | lower}}Agent(0)
{% endfor %}
    {
{% for domain in api.domains %}
  {% for command in domain.commands %}
    {% if "redirect" in command %}{% continue %}{% endif %}
    {% if "handlers" in command and not ("renderer" in command["handlers"]) %}{% continue %}{% endif %}
        m_dispatchMap.add("{{domain.domain}}.{{command.name}}", &DispatcherImpl::{{domain.domain}}_{{command.name}});
  {% endfor %}
{% endfor %}

        // Initialize common errors.
        m_commonErrors.insert(ParseError, -32700);
        m_commonErrors.insert(InvalidRequest, -32600);
        m_commonErrors.insert(MethodNotFound, -32601);
        m_commonErrors.insert(InvalidParams, -32602);
        m_commonErrors.insert(InternalError, -32603);
        m_commonErrors.insert(ServerError, -32000);
    }

    virtual void clearFrontend() { m_frontendChannel = 0; }
    virtual void dispatch(int sessionId, const String& message);
    virtual void reportProtocolError(int sessionId, int callId, CommonErrorCode, const String& errorMessage, ErrorSupport* errors) const;
    using Dispatcher::reportProtocolError;

    void sendResponse(int sessionId, int callId, const ErrorString& invocationError, ErrorSupport* errors, PassRefPtr<protocol::DictionaryValue> result);
    bool isActive() { return m_frontendChannel; }

{% for domain in api.domains %}
    virtual void registerAgent({{domain.domain}}CommandHandler* agent) { ASSERT(!m_{{domain.domain | lower}}Agent); m_{{domain.domain | lower}}Agent = agent; }
{% endfor %}

private:
    using CallHandler = void (DispatcherImpl::*)(int sessionId, int callId, DictionaryValue* messageObject, ErrorSupport* errors);
    using DispatchMap = HashMap<String, CallHandler>;

{% for domain in api.domains %}
  {% for command in domain.commands %}
    {% if "redirect" in command %}{% continue %}{% endif %}
    {% if "handlers" in command and not ("renderer" in command["handlers"]) %}{% continue %}{% endif %}
    void {{domain.domain}}_{{command.name}}(int sessionId, int callId, DictionaryValue* requestMessageObject, ErrorSupport*);
  {% endfor %}
{% endfor %}

    FrontendChannel* m_frontendChannel;

{% for domain in api.domains %}
    {{domain.domain}}CommandHandler* m_{{domain.domain | lower}}Agent;
{% endfor %}

    void sendResponse(int sessionId, int callId, ErrorString invocationError, PassRefPtr<protocol::DictionaryValue> result)
    {
        sendResponse(sessionId, callId, invocationError, nullptr, result);
    }

    void sendResponse(int sessionId, int callId, ErrorString invocationError)
    {
        sendResponse(sessionId, callId, invocationError, nullptr, DictionaryValue::create());
    }

    static const char InvalidParamsFormatString[];

    DispatchMap m_dispatchMap;
    Vector<int> m_commonErrors;
};

const char DispatcherImpl::InvalidParamsFormatString[] = "Some arguments of method '%s' can't be processed";
{% for domain in api.domains %}
  {% for command in domain.commands %}
    {% if "redirect" in command %}{% continue %}{% endif %}
    {% if "handlers" in command and not ("renderer" in command["handlers"]) %}{% continue %}{% endif %}

    {% if "async" in command %}
Dispatcher::{{domain.domain}}CommandHandler::{{command.name | to_title_case}}Callback::{{command.name | to_title_case}}Callback(PassRefPtr<DispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) { }

void Dispatcher::{{domain.domain}}CommandHandler::{{command.name | to_title_case}}Callback::sendSuccess(
      {%- for parameter in command.returns -%}
        {%- if "optional" in parameter -%}
        const Maybe<{{resolve_type(parameter).raw_type}}>& {{parameter.name}}
        {%- else -%}
        {{resolve_type(parameter).pass_type}} {{parameter.name}}
        {%- endif -%}
        {%- if not loop.last -%}, {% endif -%}
      {% endfor %})
{
    RefPtr<protocol::DictionaryValue> resultObject = DictionaryValue::create();
      {% for parameter in command.returns %}
        {% if "optional" in parameter %}
    if ({{parameter.name}}.isJust())
        resultObject->setValue("{{parameter.name}}", toValue({{parameter.name}}.fromJust()));
       {% else %}
    resultObject->setValue("{{parameter.name}}", toValue({{parameter.name}}));
        {% endif %}
      {% endfor %}
    sendIfActive(resultObject.release(), ErrorString());
}
    {% endif %}

void DispatcherImpl::{{domain.domain}}_{{command.name}}(int sessionId, int callId, DictionaryValue* requestMessageObject, ErrorSupport* errors)
{
    if (!m_{{domain.domain | lower}}Agent)
        errors->addError("{{domain.domain}} handler is not available.");

    if (errors->hasErrors()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, "{{domain.domain}}.{{command.name}}"), errors);
        return;
    }
    {% if "parameters" in command %}

    // Prepare input parameters.
    RefPtr<protocol::DictionaryValue> object = DictionaryValue::cast(requestMessageObject->get("params"));
    errors->push();
      {% for property in command.parameters %}
    RefPtr<protocol::Value> {{property.name}}Value = object ? object->get("{{property.name}}") : nullptr;
        {% if property.optional %}
    Maybe<{{resolve_type(property).raw_type}}> in_{{property.name}};
    if ({{property.name}}Value) {
        errors->setName("{{property.name}}");
        in_{{property.name}} = FromValue<{{resolve_type(property).raw_type}}>::parse({{property.name}}Value, errors);
    }
        {% else %}
    errors->setName("{{property.name}}");
    {{resolve_type(property).type}} in_{{property.name}} = FromValue<{{resolve_type(property).raw_type}}>::parse({{property.name}}Value, errors);
        {% endif %}
      {% endfor %}
    errors->pop();
    if (errors->hasErrors()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, "{{domain.domain}}.{{command.name}}"), errors);
        return;
    }
    {% endif %}

    {% if "async" in command %}
    RefPtr<{{domain.domain}}CommandHandler::{{command.name | to_title_case}}Callback> callback = adoptRef(new {{domain.domain}}CommandHandler::{{command.name | to_title_case}}Callback(this, sessionId, callId));
    {% elif "returns" in command %}
    // Declare output parameters.
    RefPtr<protocol::DictionaryValue> result = DictionaryValue::create();
      {% for property in command.returns %}
        {% if "optional" in property %}
    Maybe<{{resolve_type(property).raw_type}}> out_{{property.name}};
        {% else %}
    {{resolve_type(property).type}} out_{{property.name}};
        {% endif %}
      {% endfor %}
    {% endif %}

    ErrorString error;
    m_{{domain.domain | lower}}Agent->{{command.name}}(&error
      {%- for property in command.parameters -%}
        {%- if "optional" in property -%}
        , in_{{property.name}}
        {%- else -%}
        , {{resolve_type(property).to_pass_type % ("in_" + property.name)}}
        {%- endif -%}
      {%- endfor %}
      {%- if "async" in command -%}
        , callback.release()
      {%- elif "returns" in command %}
        {%- for property in command.returns -%}
          , &out_{{property.name}}
        {%- endfor %}
      {% endif %});
    {% if "returns" in command and not("async" in command) %}
    if (!error.length()) {
      {% for parameter in command.returns %}
        {% if "optional" in parameter %}
        if (out_{{parameter.name}}.isJust())
            result->setValue("{{parameter.name}}", toValue(out_{{parameter.name}}.fromJust()));
        {% else %}
        result->setValue("{{parameter.name}}", toValue(out_{{parameter.name}}));
        {% endif %}
      {% endfor %}
    }
    sendResponse(sessionId, callId, error, result);
    {% elif not("async" in command) %}
    sendResponse(sessionId, callId, error);
    {% endif %}
}
  {% endfor %}
{% endfor %}

PassRefPtr<Dispatcher> Dispatcher::create(FrontendChannel* frontendChannel)
{
    return adoptRef(new DispatcherImpl(frontendChannel));
}

void DispatcherImpl::dispatch(int sessionId, const String& message)
{
    RefPtr<Dispatcher> protect(this);
    int callId = 0;
    RefPtr<protocol::Value> parsedMessage = parseJSON(message);
    ASSERT(parsedMessage);
    RefPtr<protocol::DictionaryValue> messageObject = DictionaryValue::cast(parsedMessage.release());
    ASSERT(messageObject);

    RefPtr<protocol::Value> callIdValue = messageObject->get("id");
    bool success = callIdValue->asNumber(&callId);
    ASSERT_UNUSED(success, success);

    RefPtr<protocol::Value> methodValue = messageObject->get("method");
    String method;
    success = methodValue && methodValue->asString(&method);
    ASSERT_UNUSED(success, success);

    HashMap<String, CallHandler>::iterator it = m_dispatchMap.find(method);
    if (it == m_dispatchMap.end()) {
        reportProtocolError(sessionId, callId, MethodNotFound, "'" + method + "' wasn't found");
        return;
    }

    protocol::ErrorSupport errors;
    ((*this).*it->value)(sessionId, callId, messageObject.get(), &errors);
}

void DispatcherImpl::sendResponse(int sessionId, int callId, const ErrorString& invocationError, ErrorSupport* errors, PassRefPtr<protocol::DictionaryValue> result)
{
    if (invocationError.length() || (errors && errors->hasErrors())) {
        reportProtocolError(sessionId, callId, ServerError, invocationError, errors);
        return;
    }

    RefPtr<protocol::DictionaryValue> responseMessage = DictionaryValue::create();
    responseMessage->setNumber("id", callId);
    responseMessage->setObject("result", result);
    if (m_frontendChannel)
        m_frontendChannel->sendProtocolResponse(sessionId, callId, responseMessage.release());
}

void Dispatcher::reportProtocolError(int sessionId, int callId, CommonErrorCode code, const String& errorMessage) const
{
    ErrorSupport errors;
    reportProtocolError(sessionId, callId, code, errorMessage, &errors);
}

void DispatcherImpl::reportProtocolError(int sessionId, int callId, CommonErrorCode code, const String& errorMessage, ErrorSupport* errors) const
{
    ASSERT(code >=0);
    ASSERT((unsigned)code < m_commonErrors.size());
    ASSERT(m_commonErrors[code]);
    RefPtr<protocol::DictionaryValue> error = DictionaryValue::create();
    error->setNumber("code", m_commonErrors[code]);
    error->setString("message", errorMessage);
    ASSERT(error);
    if (errors && errors->hasErrors())
        error->setString("data", errors->errors());
    RefPtr<protocol::DictionaryValue> message = DictionaryValue::create();
    message->setObject("error", error);
    message->setNumber("id", callId);
    if (m_frontendChannel)
        m_frontendChannel->sendProtocolResponse(sessionId, callId, message.release());
}

bool Dispatcher::getCommandName(const String& message, String* result)
{
    RefPtr<protocol::Value> value = parseJSON(message);
    if (!value)
        return false;

    RefPtr<protocol::DictionaryValue> object = DictionaryValue::cast(value.release());
    if (!object)
        return false;

    if (!object->getString("method", result))
        return false;

    return true;
}

Dispatcher::CallbackBase::CallbackBase(PassRefPtr<DispatcherImpl> backendImpl, int sessionId, int id)
    : m_backendImpl(backendImpl), m_sessionId(sessionId), m_id(id), m_alreadySent(false) { }

Dispatcher::CallbackBase::~CallbackBase() { }

void Dispatcher::CallbackBase::sendFailure(const ErrorString& error)
{
    ASSERT(error.length());
    sendIfActive(nullptr, error);
}

bool Dispatcher::CallbackBase::isActive()
{
    return !m_alreadySent && m_backendImpl->isActive();
}

void Dispatcher::CallbackBase::sendIfActive(PassRefPtr<protocol::DictionaryValue> partialMessage, const ErrorString& invocationError)
{
    if (m_alreadySent)
        return;
    m_backendImpl->sendResponse(m_sessionId, m_id, invocationError, nullptr, partialMessage);
    m_alreadySent = true;
}

} // namespace protocol
} // namespace blink
